/**
 * Edge Detection Web Viewer
 * TypeScript implementation for displaying processed frames
 */

interface FrameData {
    width: number;
    height: number;
    data: string; // Base64 encoded image
    timestamp: number;
    processingTime?: number;
    filterType?: string;
}

class EdgeDetectionViewer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private loadingIndicator: HTMLElement;
    private statsPanel: HTMLElement;
    
    // Stats elements
    private resolutionEl: HTMLElement;
    private fpsEl: HTMLElement;
    private processingTimeEl: HTMLElement;
    private filterTypeEl: HTMLElement;
    private timestampEl: HTMLElement;
    
    private currentFrame: FrameData | null = null;
    private frameCount: number = 0;
    private lastFpsUpdate: number = Date.now();
    private simulatedFps: number = 30;

    constructor() {
        // Get DOM elements
        this.canvas = document.getElementById('imageCanvas') as HTMLCanvasElement;
        this.ctx = this.canvas.getContext('2d')!;
        this.loadingIndicator = document.getElementById('loadingIndicator')!;
        this.statsPanel = document.getElementById('statsPanel')!;
        
        this.resolutionEl = document.getElementById('resolution')!;
        this.fpsEl = document.getElementById('fps')!;
        this.processingTimeEl = document.getElementById('processingTime')!;
        this.filterTypeEl = document.getElementById('filterType')!;
        this.timestampEl = document.getElementById('timestamp')!;
        
        this.setupEventListeners();
        this.startFpsSimulation();
        
        console.log('EdgeDetectionViewer initialized');
    }

    private setupEventListeners(): void {
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        const toggleOverlayBtn = document.getElementById('toggleOverlayBtn');
        
        loadSampleBtn?.addEventListener('click', () => this.loadSampleFrame());
        toggleOverlayBtn?.addEventListener('click', () => this.toggleStatsPanel());
    }

    /**
     * Load a sample processed frame (simulated edge detection result)
     */
    private async loadSampleFrame(): Promise<void> {
        this.showLoading(true);
        
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Create a sample edge-detected frame using canvas
        const sampleFrame = this.generateSampleEdgeFrame();
        
        this.currentFrame = {
            width: 1280,
            height: 720,
            data: sampleFrame,
            timestamp: Date.now(),
            processingTime: Math.random() * 20 + 10, // 10-30ms
            filterType: 'Canny Edge Detection'
        };
        
        this.displayFrame(this.currentFrame);
        this.updateStats(this.currentFrame);
        this.showLoading(false);
        
        console.log('Sample frame loaded', this.currentFrame);
    }

    /**
     * Generate a sample edge-detected image
     */
    private generateSampleEdgeFrame(): string {
        const width = 1280;
        const height = 720;
        
        // Create temporary canvas for sample generation
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d')!;
        
        // Black background
        tempCtx.fillStyle = '#000000';
        tempCtx.fillRect(0, 0, width, height);
        
        // White edges (simulate edge detection)
        tempCtx.strokeStyle = '#FFFFFF';
        tempCtx.lineWidth = 2;
        
        // Draw some geometric shapes to simulate edges
        for (let i = 0; i < 20; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const size = Math.random() * 100 + 50;
            
            tempCtx.beginPath();
            if (Math.random() > 0.5) {
                // Rectangle
                tempCtx.rect(x, y, size, size);
            } else {
                // Circle
                tempCtx.arc(x, y, size / 2, 0, Math.PI * 2);
            }
            tempCtx.stroke();
        }
        
        // Add some random lines
        for (let i = 0; i < 30; i++) {
            tempCtx.beginPath();
            tempCtx.moveTo(Math.random() * width, Math.random() * height);
            tempCtx.lineTo(Math.random() * width, Math.random() * height);
            tempCtx.stroke();
        }
        
        // Add text overlay
        tempCtx.fillStyle = '#FFFFFF';
        tempCtx.font = '48px Arial';
        tempCtx.fillText('SAMPLE EDGE DETECTION', 50, height / 2);
        tempCtx.font = '24px Arial';
        tempCtx.fillText('Generated by TypeScript Web Viewer', 50, height / 2 + 40);
        
        return tempCanvas.toDataURL('image/png');
    }

    /**
     * Display frame on canvas
     */
    private displayFrame(frame: FrameData): void {
        const img = new Image();
        img.onload = () => {
            // Set canvas size to match image
            this.canvas.width = frame.width;
            this.canvas.height = frame.height;
            
            // Draw image
            this.ctx.drawImage(img, 0, 0, frame.width, frame.height);
            
            this.frameCount++;
        };
        img.src = frame.data;
    }

    /**
     * Update statistics display
     */
    private updateStats(frame: FrameData): void {
        this.resolutionEl.textContent = `${frame.width} Ã— ${frame.height}`;
        this.processingTimeEl.textContent = frame.processingTime 
            ? `${frame.processingTime.toFixed(2)} ms` 
            : 'N/A';
        this.filterTypeEl.textContent = frame.filterType || 'Unknown';
        this.timestampEl.textContent = new Date(frame.timestamp).toLocaleTimeString();
    }

    /**
     * Simulate FPS counter
     */
    private startFpsSimulation(): void {
        setInterval(() => {
            const now = Date.now();
            const elapsed = now - this.lastFpsUpdate;
            
            if (elapsed >= 1000) {
                // Simulate realistic FPS (25-35 range)
                this.simulatedFps = Math.floor(Math.random() * 10) + 25;
                this.fpsEl.textContent = this.simulatedFps.toString();
                this.lastFpsUpdate = now;
            }
        }, 1000);
    }

    /**
     * Toggle stats panel visibility
     */
    private toggleStatsPanel(): void {
        this.statsPanel.style.display = 
            this.statsPanel.style.display === 'none' ? 'block' : 'none';
    }

    /**
     * Show/hide loading indicator
     */
    private showLoading(show: boolean): void {
        if (show) {
            this.loadingIndicator.classList.remove('hidden');
        } else {
            this.loadingIndicator.classList.add('hidden');
        }
    }

    /**
     * Load frame from URL (for future WebSocket/HTTP integration)
     */
    public async loadFrameFromUrl(url: string): Promise<void> {
        try {
            const response = await fetch(url);
            const blob = await response.blob();
            const reader = new FileReader();
            
            reader.onloadend = () => {
                const base64data = reader.result as string;
                
                const img = new Image();
                img.onload = () => {
                    this.currentFrame = {
                        width: img.width,
                        height: img.height,
                        data: base64data,
                        timestamp: Date.now()
                    };
                    
                    this.displayFrame(this.currentFrame);
                    this.updateStats(this.currentFrame);
                };
                img.src = base64data;
            };
            
            reader.readAsDataURL(blob);
        } catch (error) {
            console.error('Failed to load frame from URL:', error);
        }
    }
}

// Initialize viewer when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    const viewer = new EdgeDetectionViewer();
    
    // Expose viewer to window for debugging
    (window as any).viewer = viewer;
    
    console.log('Edge Detection Viewer ready');
});

export { EdgeDetectionViewer, FrameData };
